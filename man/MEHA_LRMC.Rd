% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MEHA_LRMC.R
\name{MEHA_LRMC}
\alias{MEHA_LRMC}
\title{Solving low rank matrix completion hyper-parameter selection problem based on MEHA}
\usage{
MEHA_LRMC(
  M_val,
  M_tr,
  M_val_index,
  M_tr_index,
  A,
  B,
  group,
  N = 200,
  alpha = 1e-04,
  beta = 1e-04,
  eta = 1e-04,
  gamma = 10,
  c = 2,
  power = 0.48,
  tol = 0.05,
  auto_tuning = FALSE,
  temperature = 0.1
)
}
\arguments{
\item{M_val}{Input matrix for validation with dimensions n by p,
with matrix elements equal to 0 at positions other than the validation entries.}

\item{M_tr}{Input matrix for training with dimensions n by p,
with matrix elements equal to 0 at positions other than the training entries.}

\item{M_val_index}{Index of validation entries dimensions n by p,
which is a binary matrix where the positions of elements equal to 1
represent the coordinates of the validation entries in the matrix.}

\item{M_tr_index}{Index of training entries dimensions n by p,
which is a binary matrix where the positions of elements equal to 1 represent the coordinates of the training entries in the matrix.}

\item{A}{Row feature matrix of n by p.}

\item{B}{Column feature matrix of n by p.}

\item{group}{A vector to describe the feature group information,
with each
element representing the specific number of features in each group.
For example, if the coefficients of dimension 12 are divided into 3 groups which is 6, 3, and 3 dimensions,
then \code{group=(6,3,3)}. In the case of non-sequential grouping,
the permutation matrix can be converted to sequential grouping.}

\item{N}{Total iterations. Default is 200.}

\item{alpha}{Proximal gradient stepsize of \code{x}. Default is 1e-4.}

\item{beta}{Proximal gradient stepsize of \code{a} and \code{b}. Default is 1e-4.}

\item{eta}{Proximal gradient stepsize of the proxima \code{theta}. Default is 1e-4.}

\item{gamma}{Moreau envelope parameter. Default is 10.}

\item{c}{\code{\underline{c}} in MEHA,
which is used to generate the penalty parameter \code{c_k} in LV-HBA by \code{c_k = \underline{c}(k+1)^power}.
Default is 2.}

\item{power}{The power exponent in \eqn{c_k = \underline{c}(k+1)^{power}}. Default is 0.48.}

\item{tol}{Tolerance. IF \eqn{|(x^{k + 1}, y^{k + 1}) - (x^{k}, y^k)|/\sqrt{1+|(x^{k}, y^k)|^2} < tol},
then terminate the iteration, where \eqn{x^k} represents the upper-level variable, \eqn{y^k} represents the lower-level variable.
Default is 0.05.}

\item{auto_tuning}{When alpha, beta,
eta are fixed, whether an auto-hyperparameter-tuning is needed.
Default is \code{FALSE}.}

\item{temperature}{Temperature of simulating annealing method for auto-hyperparameter-tuning.
Default is 0.1.}
}
\value{
\item{x}{A vector of length (2M+1), where M denotes the total group number.
The first M values are the within-group penalty strengths of row feature
coefficients \code{a}, the second M values are within-group penalty strength
of column feature coefficients \code{b}, the last value is the penalty
strengths of low rank effect matrix \code{Q}.}
\item{a}{Row feature coefficient.}
\item{b}{Column feature coefficient.}
\item{Q}{low rank effect matrix.}
\item{X_seq}{A list. Describe the sequence x generated by MEHA in the iterative process.}
\item{a_seq}{A list. Describe the sequence a generated by MEHA in the iterative process.}
\item{b_seq}{A list. Describe the sequence b generated by MEHA in the iterative process.}
\item{Q_seq}{A list. Describe the sequence Q generated by MEHA in the iterative process.}
\item{F_seq}{The upper function value sequence generated in the iterative process based on validation set.}
}
\description{
This R function is written to solve the hyper-parameter selection problem of low-rank matrix completion using the MEHA,
please refer to the listed literature for the specific algorithm and model.
}
\examples{
# data and group
group = rbind(3,3,3,3,3,3,3,3,3,3,3,3)
n = 60
p = sum(group)
M_tr_index = matrix(0, n, n)
M_val_index = matrix(0, n, n)
M_test_index = matrix(0, n, n)
all_indices = expand.grid(1:n, 1:n)
shuffled_indices = all_indices[sample(1:(n*n)), ]
num_ones_M_tr <- 500
num_ones_M_val <- 500
num_ones_M_test <- (n*n) - num_ones_M_tr - num_ones_M_val
M_tr_index[as.matrix(shuffled_indices[1:num_ones_M_tr, ])] <- 1
M_val_index[as.matrix(shuffled_indices[(num_ones_M_tr + 1):(num_ones_M_tr + num_ones_M_val), ])] <- 1
M_test_index[as.matrix(shuffled_indices[(num_ones_M_tr + num_ones_M_val + 1):(n*n), ])] <- 1
a_0 = rbind(1,1,1,2,2,2,3,3,3,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
b_0 = rbind(1,1,1,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
u = matrix(rnorm(n), nrow = n)
v = matrix(rnorm(n), nrow = n)
Q_0 = u \%*\% t(v)
A =  matrix(rnorm(n*p), nrow = n, ncol = p)
B =  matrix(rnorm(n*p), nrow = n, ncol = p)
e_n = matrix(rep(1),nrow = n)
epsilon <- matrix(rnorm(n), n, n)
sigma = 2
M_AB = A \%*\% a_0 \%*\% t(e_n) + t(B \%*\% b_0 \%*\% t(e_n)) + sigma * epsilon
scale = norm(Q_0,type = "F")/norm(M_AB, type = "F")
M = scale*M_AB + Q_0 + sigma*epsilon
#' M_val = M * M_val_index
M_tr = M * M_tr_index
M_test = M * M_test_index
result = MEHA_LRMC(M_val, M_tr,M_test, M_val_index, M_tr_index,M_test_index, A, B, group, 200)
}
\references{
Liu, R., Liu, Z., Yao, W., Zeng, S., & Zhang, J. (2024).
"Rethinking Moreau Envelope for Nonconvex Bi-Level Optimization: A Single-loop and Hessian-free Solution Strategy."
Available at: https://openreview.net/forum?id=i6EtCiIK4a

\if{html}{\out{<div class="sourceCode">}}\preformatted{Gao, L., Ye, J. J., Yin, H., Zeng, S., & Zhang, J. (2022).
"Value function based difference-of-convex algorithm for bilevel hyperparameter selection problems."
Available at: https://proceedings.mlr.press/v162/gao22j.html
}\if{html}{\out{</div>}}
}
